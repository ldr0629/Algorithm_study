# 5.Bit Manipulation

비트 조작을 명시적으로 요구하는 문제들도 있는 한편, 코드를 최적화할 때 유용하게 사용되는 기법으로
활용되기도 한다.

    Ex)
    1. 0110 + 0110 = 1100
    0110 * 2와 같으므로 왼쪽 비트 시프트 연산을 한 결과와 같다.
    
    2. 0100 * 0011 = 1100
    0100은 4이므로 0011에 왼쪽으로 두 번 시프트하는 것과 같다.
    
    3. 1101 ^ (~1101) = 1111
    어떤 비트와 그 비트를 부정한 값을 XOR하면 항상 1이되므로 a^(~a)를 하면 모든 비트가 1이 된다.
    
    4. 1011 & (~0 << 2) = 1000
    ~0을 하면 모든 비트가 1이 된다. 따라서, ~0 << 2을 하면 마지막 비트 두 개는 0이 되고
    나머지는 모두 1이 된다. 이 값과 다른 값을 AND 연산하면 masking되어 1000이 나온다.

## 2의 보수와 음수

컴퓨터는 일반적으로 정수를 저장할 때 2의 보수 형태로 저장한다. 양수를 표현할 때는
아무 문제 없지만 음수를 표현할 때는 그 수의 절댓값에 부호 비트를 1로 세팅한 뒤
2의 보수를 취한 형태로 표현한다.

2의 보수를 표현하는 방법으로 양수로 표현된 2진수를 뒤집은 뒤 1을 더해 주는 것이다.
예를 들어 3을 2진수로 표현하면 011이 되는데, 이 숫자를 뒤집으면 100이 되고, 여기에 1을
더하면 101이 된다. 마지막으로 부호 비트를 앞에 붙여 주면 1101이 된다.

## 기본적 비트 조작: 비트값 확인 및 채워넣기

### 비트값 확인

>아래의 메소드는 1을 i비트만큼 시프트해서 00010000과 같은 값을 만든다.  그 다음
AND 연산을 통해 num의 i번째 비트를 뺀 나머지 비트를 모두 삭제한 뒤, 이 값을 0과 비교한다.
이 값이 0이 아니라면 i번째 비트는 1이어야 하고, 0이라면 i번째 비트는 0이어야 한다.

```java
boolean getBit(int num, int i) {
	return ((num & (1 << i)) != 0);
}
```

### 비트값 채워넣기

>SetBit는 1을 i비트만큼 시프트해서 00010000과 같은 값을 만든다. 그 다음 OR 연산을 통해
num의 i번째 비트값을 바꾼다. i번째를 제외한 나머지 비트들은 0과 OR 연산을 하게 되므로 
num에 아무 영향을 끼치지 않는다.

```java
int setBit(int num, int i) {
	return num | (1 << i);
}
```
